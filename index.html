<!DOCTYPE html>
        <html lang="en">
        <head>
            <title>vibeirc</title>
            <meta charset="utf-8" />
            <style type="text/css">
                table, tr, td
                {
                    /* putting these on their own line caused most of the document to be left out (dmd bug?) */
                    border-collapse: collapse; border: 1px solid black; padding: 5px;
                }
            </style>
        </head>
        <body>
            <h1>vibeirc</h1>
            <!-- Generated by Ddoc from src/vibeirc.d -->

<dl><dt><big><a name="RPL_WELCOME"></a><u>RPL_WELCOME</u><br><a name="RPL_YOURHOST"></a><u>RPL_YOURHOST</u><br><a name="RPL_CREATED"></a><u>RPL_CREATED</u><br><a name="RPL_MYINFO"></a><u>RPL_MYINFO</u></big></dt>
<dd>The server sends <u>RPL_WELCOME</u> through RPL_MYINFO to a user upon successful registration.<br><br>

</dd>
<dt><big><a name="RPL_BOUNCE"></a><u>RPL_BOUNCE</u></big></dt>
<dd>Sent by the server to a user to suggest an alternative server.
        This is often used when the connection is refused because the server is already full.<br><br>

</dd>
<dt><big><a name="RPL_USERHOST"></a><u>RPL_USERHOST</u></big></dt>
<dd>Reply format used by USERHOST to list replies to the query list.<br><br>

</dd>
<dt><big><a name="RPL_ISON"></a><u>RPL_ISON</u></big></dt>
<dd>Reply format used by ISON to list replies to the query list.<br><br>

</dd>
<dt><big><a name="RPL_AWAY"></a><u>RPL_AWAY</u><br><a name="RPL_UNAWAY"></a><u>RPL_UNAWAY</u><br><a name="RPL_NOWAWAY"></a><u>RPL_NOWAWAY</u></big></dt>
<dd>These replies are used with the AWAY command (if allowed).
        <u>RPL_AWAY</u> is sent to any client sending a PRIVMSG to a client which is away.
        <u>RPL_AWAY</u> is only sent by the server to which the client is connected.
        Replies RPL_UNAWAY and RPL_NOWAWAY are sent when the client removes and sets an AWAY message.<br><br>

</dd>
<dt><big><a name="RPL_WHOISUSER"></a><u>RPL_WHOISUSER</u><br><a name="RPL_WHOISSERVER"></a><u>RPL_WHOISSERVER</u><br><a name="RPL_WHOISOPERATOR"></a><u>RPL_WHOISOPERATOR</u><br><a name="RPL_WHOISIDLE"></a><u>RPL_WHOISIDLE</u><br><a name="RPL_ENDOFWHOIS"></a><u>RPL_ENDOFWHOIS</u><br><a name="RPL_WHOISCHANNELS"></a><u>RPL_WHOISCHANNELS</u></big></dt>
<dd>Replies <u>RPL_WHOISUSER</u> through RPL_WHOIS, RPL_WHOISIDLE through RPL_WHOISCHANNELS are all replies generated in response to a WHOIS message.
        Given that there are enough parameters present,
        the answering server MUST either formulate a reply out of the above numerics
        (if the query nick is found) or return an error reply.
        The '*' in <u>RPL_WHOISUSER</u> is there as the literal character and not as a wild card.
        For each reply set, only RPL_WHOISCHANNELS may appear more than once
        (for long lists of channel names).
        The '@' and '+' characters next to the channel name indicate whether
        a client is a channel operator or has been granted permission to speak on a moderated channel.
        The RPL_ENDOFWHOIS reply is used to mark the end of processing a WHOIS message.<br><br>

</dd>
<dt><big><a name="RPL_WHOWASUSER"></a><u>RPL_WHOWASUSER</u><br><a name="RPL_ENDOFWHOWAS"></a><u>RPL_ENDOFWHOWAS</u></big></dt>
<dd>When replying to a WHOWAS message, a server MUST use the replies
        <u>RPL_WHOWASUSER</u>, RPL_WHOISSERVER or ERR_WASNOSUCHNICK for each nickname in the presented list.
        At the end of all reply batches, there MUST be RPL_ENDOFWHOWAS
        (even if there was only one reply and it was an error).<br><br>

</dd>
<dt><big><a name="RPL_LIST"></a><u>RPL_LIST</u><br><a name="RPL_LISTEND"></a><u>RPL_LISTEND</u></big></dt>
<dd>Replies <u>RPL_LIST</u>, RPL_LISTEND mark the actual replies with data
        and end of the server's responseto a LIST command.
        If there are no channels available to return,  only the end reply MUST be sent.
<br><br>
ditto<br><br>

</dd>
<dt><big><a name="RPL_LISTSTART"></a><u>RPL_LISTSTART</u></big></dt>
<dd>Obsolete. Not used.<br><br>

</dd>
<dt><big><a name="RPL_UNIQOPIS"></a><u>RPL_UNIQOPIS</u></big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RPL_CHANNELMODEIS"></a><u>RPL_CHANNELMODEIS</u></big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RPL_NOTOPIC"></a><u>RPL_NOTOPIC</u><br><a name="RPL_TOPIC"></a><u>RPL_TOPIC</u></big></dt>
<dd>When sending a TOPIC message to determine the channel topic, one of two replies is sent.
        If the topic is set, RPL_TOPIC is sent back else <u>RPL_NOTOPIC</u>.
<br><br>
ditto<br><br>

</dd>
<dt><big><a name="RPL_INVITING"></a><u>RPL_INVITING</u></big></dt>
<dd>Returned by the server to indicate that the attempted INVITE message
        was successful and is being passed onto the end client.<br><br>

</dd>
<dt><big><a name="RPL_SUMMONING"></a><u>RPL_SUMMONING</u></big></dt>
<dd>Returned by a server answering a SUMMON message to indicate that it is summoning that user.<br><br>

</dd>
<dt><big><a name="RPL_INVITELIST"></a><u>RPL_INVITELIST</u><br><a name="RPL_ENDOFINVITELIST"></a><u>RPL_ENDOFINVITELIST</u></big></dt>
<dd>When listing the 'invitations masks' for a given channel,
        a server is required to send the list back using the <u>RPL_INVITELIST</u>
        and RPL_ENDOFINVITELIST messages.
        A separate <u>RPL_INVITELIST</u> is sent for each active mask.
        After the masks have been listed (or if none present)
        a RPL_ENDOFINVITELIST MUST be sent.<br><br>

</dd>
<dt><big><a name="RPL_EXCEPTLIST"></a><u>RPL_EXCEPTLIST</u><br><a name="RPL_ENDOFEXCEPTLIST"></a><u>RPL_ENDOFEXCEPTLIST</u></big></dt>
<dd>When listing the 'exception masks' for a given channel,
        a server is required to send the list back using the <u>RPL_EXCEPTLIST</u>
        and RPL_ENDOFEXCEPTLIST messages.
        A separate <u>RPL_EXCEPTLIST</u> is sent for each active mask.
        After the masks have been listed (or if none present)
        a RPL_ENDOFEXCEPTLIST MUST be sent.<br><br>

</dd>
<dt><big><a name="RPL_VERSION"></a><u>RPL_VERSION</u></big></dt>
<dd>Reply by the server showing its version details.<br><br>

</dd>
<dt><big><a name="RPL_WHOREPLY"></a><u>RPL_WHOREPLY</u><br><a name="RPL_ENDOFWHO"></a><u>RPL_ENDOFWHO</u></big></dt>
<dd>The <u>RPL_WHOREPLY</u> and RPL_ENDOFWHO pair are used to answer a WHO message.
        The <u>RPL_WHOREPLY</u> is only sent if there is an appropriate match to the WHO query.<br><br>

</dd>
<dt><big><a name="RPL_NAMREPLY"></a><u>RPL_NAMREPLY</u><br><a name="RPL_ENDOFNAMES"></a><u>RPL_ENDOFNAMES</u></big></dt>
<dd>To reply to a NAMES message, a reply pair consisting of <u>RPL_NAMREPLY</u>
        and RPL_ENDOFNAMES is sent by the server back to the client.
        If there is no channel found as in the query, then only RPL_ENDOFNAMES is returned.
        The exception to this is when a NAMES message is sent with no parameters
        and all visible channels and contents are sent back in a series of
        RPL_NAMEREPLY messages with a RPL_ENDOFNAMES to mark the end.<br><br>

</dd>
<dt><big><a name="RPL_LINKS"></a><u>RPL_LINKS</u><br><a name="RPL_ENDOFLINKS"></a><u>RPL_ENDOFLINKS</u></big></dt>
<dd>In replying to the LINKS message, a server MUST send replies back using the <u>RPL_LINKS</u>
        numeric and mark the end of the list using an RPL_ENDOFLINKS reply.<br><br>

</dd>
<dt><big><a name="RPL_BANLIST"></a><u>RPL_BANLIST</u><br><a name="RPL_ENDOFBANLIST"></a><u>RPL_ENDOFBANLIST</u></big></dt>
<dd>When listing the active 'bans' for a given channel, a server is required
        to send the list back using the <u>RPL_BANLIST</u> and RPL_ENDOFBANLIST messages.
        A separate <u>RPL_BANLIST</u> is sent for each active banmask.
        After the banmasks have been listed (or if none present) a RPL_ENDOFBANLIST MUST be sent.<br><br>

</dd>
<dt><big><a name="RPL_INFO"></a><u>RPL_INFO</u><br><a name="RPL_ENDOFINFO"></a><u>RPL_ENDOFINFO</u></big></dt>
<dd>A server responding to an INFO message is required to send all its 'info' in a series of
        <u>RPL_INFO</u> messages with a RPL_ENDOFINFO reply to indicate the end of the replies.<br><br>

</dd>
<dt><big><a name="RPL_MOTDSTART"></a><u>RPL_MOTDSTART</u><br><a name="RPL_MOTD"></a><u>RPL_MOTD</u><br><a name="RPL_ENDOFMOTD"></a><u>RPL_ENDOFMOTD</u></big></dt>
<dd>When responding to the MOTD message and the MOTD file is found,
        the file is displayed line by line, with each line no longer than 80 characters,
        using RPL_MOTD format replies.
        These MUST be surrounded by a <u>RPL_MOTDSTART</u> (before the RPL_MOTDs)
        and an RPL_ENDOFMOTD (after).<br><br>

</dd>
<dt><big><a name="RPL_YOUREOPER"></a><u>RPL_YOUREOPER</u></big></dt>
<dd><u>RPL_YOUREOPER</u> is sent back to a client which has just successfully issued
        an OPER message and gained operator status.<br><br>

</dd>
<dt><big><a name="RPL_REHASHING"></a><u>RPL_REHASHING</u></big></dt>
<dd>If the REHASH option is used and an operator sends a REHASH message,
        an <u>RPL_REHASHING</u> is sent back to the operator.<br><br>

</dd>
<dt><big><a name="RPL_YOURESERVICE"></a><u>RPL_YOURESERVICE</u></big></dt>
<dd>Sent by the server to a service upon successful registration.<br><br>

</dd>
<dt><big><a name="RPL_TIME"></a><u>RPL_TIME</u></big></dt>
<dd>When replying to the TIME message, a server MUST send the reply using the <u>RPL_TIME</u> format above.
        The string showing the time need only contain the correct day and time there.
        There is no further requirement for the time string.<br><br>

</dd>
<dt><big><a name="RPL_USERSSTART"></a><u>RPL_USERSSTART</u><br><a name="RPL_USERS"></a><u>RPL_USERS</u><br><a name="RPL_ENDOFUSERS"></a><u>RPL_ENDOFUSERS</u><br><a name="RPL_NOUSERS"></a><u>RPL_NOUSERS</u></big></dt>
<dd>If the USERS message is handled by a server, the replies RPL_USERSTART,
        RPL_USERS, RPL_ENDOFUSERS and RPL_NOUSERS are used.
        <u>RPL_USERSSTART</u> MUST be sent first, following by either a sequence of RPL_USERS
        or a single RPL_NOUSER.
        Following this is RPL_ENDOFUSERS.<br><br>

</dd>
<dt><big><a name="RPL_TRACELINK"></a><u>RPL_TRACELINK</u><br><a name="RPL_TRACECONNECTING"></a><u>RPL_TRACECONNECTING</u><br><a name="RPL_TRACEHANDSHAKE"></a><u>RPL_TRACEHANDSHAKE</u><br><a name="RPL_TRACEUNKNOWN"></a><u>RPL_TRACEUNKNOWN</u><br><a name="RPL_TRACEOPERATOR"></a><u>RPL_TRACEOPERATOR</u><br><a name="RPL_TRACEUSER"></a><u>RPL_TRACEUSER</u><br><a name="RPL_TRACESERVER"></a><u>RPL_TRACESERVER</u><br><a name="RPL_TRACESERVICE"></a><u>RPL_TRACESERVICE</u><br><a name="RPL_TRACENEWTYPE"></a><u>RPL_TRACENEWTYPE</u><br><a name="RPL_TRACECLASS"></a><u>RPL_TRACECLASS</u><br><a name="RPL_TRACELOG"></a><u>RPL_TRACELOG</u><br><a name="RPL_TRACEEND"></a><u>RPL_TRACEEND</u></big></dt>
<dd>The RPL_TRACE* are all returned by the server in response to the TRACE message.
        How many are returned is dependent on the TRACE message and whether it was sent by an operator or not.
        There is no predefined order for which occurs first.
        Replies RPL_TRACEUNKNOWN, RPL_TRACECONNECTING and RPL_TRACEHANDSHAKE are all used for connections
        which have not been fully established and are either unknown,
        still attempting to connect or in the process of completing the 'server handshake'.
        <u>RPL_TRACELINK</u> is sent by any server which handlesa TRACE message and has to pass it on to another server.
        The list of RPL_TRACELINKs sent in response to a TRACE command traversing the IRC network
        should reflect the actual connectivity ofthe servers themselves along that path.
        RPL_TRACENEWTYPE is to be used for any connection which does not fit in the other categories
        but is being displayed anyway.
        RPL_TRACEEND is sent to indicate the end of the list.<br><br>

</dd>
<dt><big><a name="RPL_TRACERECONNECT"></a><u>RPL_TRACERECONNECT</u></big></dt>
<dd>Unused.<br><br>

</dd>
<dt><big><a name="RPL_STATSLINKINFO"></a><u>RPL_STATSLINKINFO</u><br><a name="RPL_STATSCOMMANDS"></a><u>RPL_STATSCOMMANDS</u><br><a name="RPL_ENDOFSTATS"></a><u>RPL_ENDOFSTATS</u><br><a name="RPL_STATSUPTIME"></a><u>RPL_STATSUPTIME</u><br><a name="RPL_STATSOLINE"></a><u>RPL_STATSOLINE</u></big></dt>
<dd>Returned from the server in response to the STATS message.<br><br>

</dd>
<dt><big><a name="RPL_UMODEIS"></a><u>RPL_UMODEIS</u></big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RPL_SERVLIST"></a><u>RPL_SERVLIST</u></big></dt>
<dd><br><br>
</dd>
<dt><big><a name="RPL_SERVLISTEND"></a><u>RPL_SERVLISTEND</u></big></dt>
<dd>When listing services in reply to a SERVLIST message,
        a server is required to send the list back using the RPL_SERVLIST
        and <u>RPL_SERVLISTEND</u> messages.
        A separate RPL_SERVLIST is sent for each service.
        After the services have been listed (or if none present) a <u>RPL_SERVLISTEND</u> MUST be sent.<br><br>

</dd>
<dt><big><a name="RPL_LUSERCLIENT"></a><u>RPL_LUSERCLIENT</u><br><a name="RPL_LUSEROP"></a><u>RPL_LUSEROP</u><br><a name="RPL_LUSERUNKNOWN"></a><u>RPL_LUSERUNKNOWN</u><br><a name="RPL_LUSERCHANNELS"></a><u>RPL_LUSERCHANNELS</u><br><a name="RPL_LUSERME"></a><u>RPL_LUSERME</u></big></dt>
<dd>In processing an LUSERS message, the server sends a set of replies from
        <u>RPL_LUSERCLIENT</u>, RPL_LUSEROP, RPL_USERUNKNOWN, RPL_LUSERCHANNELS and RPL_LUSERME.
        When replying, a server MUST send back <u>RPL_LUSERCLIENT</u> and RPL_LUSERME.
        The other replies are only sent back if a non-zero count is found for them.<br><br>

</dd>
<dt><big><a name="RPL_ADMINME"></a><u>RPL_ADMINME</u><br><a name="RPL_ADMINLOC1"></a><u>RPL_ADMINLOC1</u><br><a name="RPL_ADMINLOC2"></a><u>RPL_ADMINLOC2</u><br><a name="RPL_ADMINEMAIL"></a><u>RPL_ADMINEMAIL</u></big></dt>
<dd>When replying to an ADMIN message, a server is expected to use replies <u>RPL_ADMINME</u>
        through to RPL_ADMINEMAIL and provide a text message with each.
        For RPL_ADMINLOC1 a description of what city, state and country the server is in is expected,
        followed by details of the institution (RPL_ADMINLOC2)
        and finally the administrative contact for the server (an email address here is REQUIRED)
        in RPL_ADMINEMAIL.<br><br>

</dd>
<dt><big><a name="RPL_TRYAGAIN"></a><u>RPL_TRYAGAIN</u></big></dt>
<dd>When a server drops a command without processing it,
        it MUST use the reply <u>RPL_TRYAGAIN</u> to inform the originating client.<br><br>

</dd>
<dt><big><a name="ERR_NOSUCHNICK"></a><u>ERR_NOSUCHNICK</u></big></dt>
<dd>Used to indicate the nickname parameter supplied to a command is currently unused.<br><br>

</dd>
<dt><big><a name="ERR_NOSUCHSERVER"></a><u>ERR_NOSUCHSERVER</u></big></dt>
<dd>Used to indicate the server name given currently does not exist.<br><br>

</dd>
<dt><big><a name="ERR_NOSUCHCHANNEL"></a><u>ERR_NOSUCHCHANNEL</u></big></dt>
<dd>Used to indicate the given channel name is invalid.<br><br>

</dd>
<dt><big><a name="ERR_CANNOTSENDTOCHAN"></a><u>ERR_CANNOTSENDTOCHAN</u></big></dt>
<dd>Sent to a user who is either (a) not on a channel which is mode +n
        or (b) not a chanop (or mode +v) on a channel which has mode +m set
        or where the user is banned and is trying to send a PRIVMSG message to that channel.<br><br>

</dd>
<dt><big><a name="ERR_TOOMANYCHANNELS"></a><u>ERR_TOOMANYCHANNELS</u></big></dt>
<dd>Sent to a user when they have joined the maximum number
        of allowed channels and they try to join another channel.<br><br>

</dd>
<dt><big><a name="ERR_WASNOSUCHNICK"></a><u>ERR_WASNOSUCHNICK</u></big></dt>
<dd>Returned by WHOWAS to indicate there is no history information for that nickname.<br><br>

</dd>
<dt><big><a name="ERR_TOOMANYTARGETS"></a><u>ERR_TOOMANYTARGETS</u></big></dt>
<dd>Returned to a client which is attempting to send a PRIVMSG/NOTICE
        using the user@host destination format and for a user@host which has several occurrences.
        Returned to a client which trying to send a PRIVMSG/NOTICE to too many recipients.
        Returned to a client which is attempting to JOIN a safe channel
        using the shortname when there are more than one such channel.<br><br>

</dd>
<dt><big><a name="ERR_NOSUCHSERVICE"></a><u>ERR_NOSUCHSERVICE</u></big></dt>
<dd>Returned to a client which is attempting to send a SQUERY to a service which does not exist.<br><br>

</dd>
<dt><big><a name="ERR_NOORIGIN"></a><u>ERR_NOORIGIN</u></big></dt>
<dd>PING or PONG message missing the originator parameter.<br><br>

</dd>
<dt><big><a name="ERR_NORECIPIENT"></a><u>ERR_NORECIPIENT</u><br><a name="ERR_NOTEXTTOSEND"></a><u>ERR_NOTEXTTOSEND</u><br><a name="ERR_NOTOPLEVEL"></a><u>ERR_NOTOPLEVEL</u><br><a name="ERR_WILDTOPLEVEL"></a><u>ERR_WILDTOPLEVEL</u><br><a name="ERR_BADMASK"></a><u>ERR_BADMASK</u></big></dt>
<dd>ERR_NOTEXTTOSEND through ERR_BADMASK are returned by PRIVMSG to indicate that the message
        wasn't delivered for some reason.
        ERR_NOTOPLEVEL and ERR_WILDTOPLEVEL are errors that are returned
        when an invalid use of "PRIVMSG $<server>" or "PRIVMSG #<host>" is attempted.<br><br>

</dd>
<dt><big><a name="ERR_UNKNOWNCOMMAND"></a><u>ERR_UNKNOWNCOMMAND</u></big></dt>
<dd>Returned to a registered client to indicate
        that the command sent is unknown by the server.<br><br>

</dd>
<dt><big><a name="ERR_NOMOTD"></a><u>ERR_NOMOTD</u></big></dt>
<dd>Server's MOTD file could not be opened by the server.<br><br>

</dd>
<dt><big><a name="ERR_NOADMININFO"></a><u>ERR_NOADMININFO</u></big></dt>
<dd>Returned by a server in response to an ADMIN message
        when there is an error in finding the appropriate information.<br><br>

</dd>
<dt><big><a name="ERR_FILEERROR"></a><u>ERR_FILEERROR</u></big></dt>
<dd>Generic error message used to report a failed file
        operation during the processing of a message.<br><br>

</dd>
<dt><big><a name="ERR_NONICKNAMEGIVEN"></a><u>ERR_NONICKNAMEGIVEN</u></big></dt>
<dd>Returned when a nickname parameter expected for a command and isn't found.<br><br>

</dd>
<dt><big><a name="ERR_ERRONEUSNICKNAME"></a><u>ERR_ERRONEUSNICKNAME</u></big></dt>
<dd>Returned after receiving a NICK message
        which contains characters which do not fall in the defined set.<br><br>

</dd>
<dt><big><a name="ERR_NICKNAMEINUSE"></a><u>ERR_NICKNAMEINUSE</u></big></dt>
<dd>Returned when a NICK message is processed that results
        in an attempt to change to a currently existing nickname.<br><br>

</dd>
<dt><big><a name="ERR_NICKCOLLISION"></a><u>ERR_NICKCOLLISION</u></big></dt>
<dd>Returned by a server to a client when it detects a nickname collision
        (registered of a NICK that already exists by another server).<br><br>

</dd>
<dt><big><a name="WHITE"></a><u>WHITE</u><br><a name="BLACK"></a><u>BLACK</u><br><a name="BLUE"></a><u>BLUE</u><br><a name="GREEN"></a><u>GREEN</u><br><a name="RED"></a><u>RED</u><br><a name="BROWN"></a><u>BROWN</u><br><a name="PURPLE"></a><u>PURPLE</u><br><a name="ORANGE"></a><u>ORANGE</u><br><a name="YELLOW"></a><u>YELLOW</u><br><a name="LIGHTGREEN"></a><u>LIGHTGREEN</u><br><a name="TEAL"></a><u>TEAL</u><br><a name="LIGHTCYAN"></a><u>LIGHTCYAN</u><br><a name="LIGHTBLUE"></a><u>LIGHTBLUE</u><br><a name="PINK"></a><u>PINK</u><br><a name="GREY"></a><u>GREY</u><br><a name="LIGHTGREY"></a><u>LIGHTGREY</u><br><a name="TRANSPARENT"></a><u>TRANSPARENT</u></big></dt>
<dd>Color codes for use with <a href="#color">color</a>.<br><br>

</dd>
<dt><big><a name="ConnectionParameters"></a>struct <u>ConnectionParameters</u>;
</big></dt>
<dd>A struct containing details about a connection.<br><br>

<dl><dt><big><a name="ConnectionParameters.hostname"></a>string <u>hostname</u>;
</big></dt>
<dd>The hostname or address of the IRC server.<br><br>

</dd>
<dt><big><a name="ConnectionParameters.port"></a>ushort <u>port</u>;
</big></dt>
<dd>The port of the server.<br><br>

</dd>
<dt><big><a name="ConnectionParameters.password"></a>string <u>password</u>;
</big></dt>
<dd>The password for the server, if any.<br><br>

</dd>
<dt><big><a name="ConnectionParameters.username"></a>string <u>username</u>;
</big></dt>
<dd>The username, later used by the server in this connection's hostmask.<br><br>

</dd>
<dt><big><a name="ConnectionParameters.realname"></a>string <u>realname</u>;
</big></dt>
<dd>The realname as returned by the WHOIS command.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="User"></a>struct <u>User</u>;
</big></dt>
<dd>A struct containing details about a user.<br><br>

<dl><dt><big><a name="User.nickname"></a>string <u>nickname</u>;
</big></dt>
<dd>The nickname of this user.<br><br>

</dd>
<dt><big><a name="User.username"></a>string <u>username</u>;
</big></dt>
<dd>The username portion of this user's hostmask.<br><br>

</dd>
<dt><big><a name="User.hostname"></a>string <u>hostname</u>;
</big></dt>
<dd>The hostname portion of this user's hostmask.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="Message"></a>struct <u>Message</u>;
</big></dt>
<dd>A struct containing details about an incoming message.<br><br>

<dl><dt><big><a name="Message.sender"></a>User <u>sender</u>;
</big></dt>
<dd>The user who sent the message.<br><br>

</dd>
<dt><big><a name="Message.receiver"></a>string <u>receiver</u>;
</big></dt>
<dd>The destination of the message, either a user or a channel.<br><br>

</dd>
<dt><big><a name="Message.ctcpCommand"></a>string <u>ctcpCommand</u>;
</big></dt>
<dd>The CTCP command, if any.<br><br>

</dd>
<dt><big><a name="Message.message"></a>string <u>message</u>;
</big></dt>
<dd>The message body.<br><br>

</dd>
<dt><big><a name="Message.isCTCP"></a>@property bool <u>isCTCP</u>();
</big></dt>
<dd>Returns whether this message uses CTCP.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="IRCConnection"></a>class <u>IRCConnection</u>;
</big></dt>
<dd>The base class for IRC connections.<br><br>

<dl><dt><big><a name="IRCConnection.connectionParameters"></a>ConnectionParameters <u>connectionParameters</u>;
</big></dt>
<dd>The connection parameters passed to <a href="#irc_connect">irc_connect</a>.<br><br>

</dd>
<dt><big><a name="IRCConnection.transport"></a>TCPConnection <u>transport</u>;
</big></dt>
<dd>The vibe socket underlying this connection.<br><br>

</dd>
<dt><big><a name="IRCConnection.sleepTimeout"></a>Duration <u>sleepTimeout</u>;
</big></dt>
<dd>How long the protocol loop should sleep after failing to read a line.<br><br>

</dd>
<dt><big><a name="IRCConnection.buffering"></a>bool <u>buffering</u>;
</big></dt>
<dd>Whether to buffer outgoing messages.<br><br>

</dd>
<dt><big><a name="IRCConnection.bufferLimit"></a>uint <u>bufferLimit</u>;
</big></dt>
<dd>Maximum number of messages to send per time period, if buffering is enabled.<br><br>

</dd>
<dt><big><a name="IRCConnection.bufferTimeout"></a>Duration <u>bufferTimeout</u>;
</big></dt>
<dd>Amount of time to wait before sending each batch of messages, if buffering is enabled.<br><br>

</dd>
<dt><big><a name="IRCConnection.this"></a>protected this();
</big></dt>
<dd>Default constructor. Should not be called from user code.
<br><br>
<b>See Also:</b><br>
<a href="#irc_connect">irc_connect</a><br><br>

</dd>
<dt><big><a name="IRCConnection.nickname"></a>final @property string <u>nickname</u>();
</big></dt>
<dd>Get this connection's nickname.<br><br>

</dd>
<dt><big><a name="IRCConnection.nickname"></a>final @property string <u>nickname</u>(string <i>newNick</i>);
</big></dt>
<dd>Set this connection's nickname.<br><br>

</dd>
<dt><big><a name="IRCConnection.connect"></a>final void <u>connect</u>();
</big></dt>
<dd>Connect to the IRC network and start the protocol loop.
<br><br>
Called from <a href="#irc_connect">irc_connect</a>, so calling this is only necessary for reconnects.<br><br>

</dd>
<dt><big><a name="IRCConnection.disconnect"></a>final void <u>disconnect</u>(string <i>reason</i>);
</big></dt>
<dd>Disconnect from the network, giving <i>reason</i> as the quit message.<br><br>

</dd>
<dt><big><a name="IRCConnection.send_line"></a>final void <u>send_line</u>(Args...)(string <i>contents</i>, Args <i>args</i>);
</big></dt>
<dd>Send a formatted line.
<br><br>
<b>Params:</b><br>
<table><tr><td>string contents</td>
<td>format string for the line</td></tr>
<tr><td>Args args</td>
<td>formatting arguments</td></tr>
</table><br>

</dd>
<dt><big><a name="IRCConnection.send_message"></a>final void <u>send_message</u>(string <i>destination</i>, string <i>message</i>, bool <i>notice</i> = false);
</big></dt>
<dd>Send a message.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>destination</i></td>
<td>destination of the <i>message</i>, either a #channel or a nickname</td></tr>
<tr><td>bool <i>notice</i></td>
<td>send a NOTICE instead of a PRIVMSG</td></tr>
</table><br>

</dd>
<dt><big><a name="IRCConnection.join_channel"></a>final void <u>join_channel</u>(string <i>name</i>);
</big></dt>
<dd>Join a channel.<br><br>

</dd>
<dt><big><a name="IRCConnection.unknown_command"></a>void <u>unknown_command</u>(string <i>prefix</i>, string <i>command</i>, string[] <i>arguments</i>);
</big></dt>
<dd>Called when an unknown <i>command</i> is received.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>prefix</i></td>
<td>origin of the command, either a server or a user</td></tr>
<tr><td>string <i>command</i></td>
<td>the name of the command</td></tr>
<tr><td>string[] <i>arguments</i></td>
<td>the body of the command</td></tr>
</table><br>

</dd>
<dt><big><a name="IRCConnection.unknown_numeric"></a>void <u>unknown_numeric</u>(string <i>prefix</i>, int <i>id</i>, string[] <i>arguments</i>);
</big></dt>
<dd>Called when an unknown numeric command is received.
<br><br>
<b>Params:</b><br>
<table><tr><td>string <i>prefix</i></td>
<td>origin of the command, either a server or a user</td></tr>
<tr><td>int <i>id</i></td>
<td>the number of the command</td></tr>
<tr><td>string[] <i>arguments</i></td>
<td>the body of the command</td></tr>
</table><br>

</dd>
<dt><big><a name="IRCConnection.signed_on"></a>void <u>signed_on</u>();
</big></dt>
<dd>Called after succesfully logging in to the network.<br><br>

</dd>
<dt><big><a name="IRCConnection.disconnected"></a>void <u>disconnected</u>(string <i>reason</i>);
</big></dt>
<dd>Called after being disconnected from the network.<br><br>

</dd>
<dt><big><a name="IRCConnection.privmsg"></a>void <u>privmsg</u>(Message <i>message</i>);
</big></dt>
<dd>Called upon reception of an incoming private <i>message</i>.<br><br>

</dd>
<dt><big><a name="IRCConnection.notice"></a>void <u>notice</u>(Message <i>message</i>);
</big></dt>
<dd>Called upon reception of an incoming notice.
<br><br>
A notice is similar to a privmsg, except it is expected to not generate automatic replies.<br><br>

</dd>
<dt><big><a name="IRCConnection.user_joined"></a>void <u>user_joined</u>(User <i>user</i>, string <i>channel</i>);
</big></dt>
<dd>Called when a user joins a channel.<br><br>

</dd>
<dt><big><a name="IRCConnection.user_left"></a>void <u>user_left</u>(User <i>user</i>, string <i>channel</i>, string <i>reason</i>);
</big></dt>
<dd>Called when a user leaves a channel.<br><br>

</dd>
<dt><big><a name="IRCConnection.user_quit"></a>void <u>user_quit</u>(User <i>user</i>, string <i>reason</i>);
</big></dt>
<dd>Called when a user disconnects from the network.<br><br>

</dd>
<dt><big><a name="IRCConnection.user_kicked"></a>void <u>user_kicked</u>(User <i>kicker</i>, string <i>user</i>, string <i>channel</i>, string <i>reason</i>);
</big></dt>
<dd>Called when a user is kicked from a channel.
<br><br>
<b>Params:</b><br>
<table><tr><td>User <i>kicker</i></td>
<td>the user that performed the kick</td></tr>
<tr><td>string <i>user</i></td>
<td>the user that was kicked</td></tr>
</table><br>

</dd>
<dt><big><a name="IRCConnection.user_renamed"></a>void <u>user_renamed</u>(User <i>user</i>, string <i>oldNick</i>);
</big></dt>
<dd>Called when a user changes their nickname.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="irc_connect"></a>ConnectionClass <u>irc_connect</u>(ConnectionClass)(ConnectionParameters <i>parameters</i>) if (is(ConnectionClass : IRCConnection));
</big></dt>
<dd>Establish a connection to a network and construct an instance of ConnectionClass
    to handle events from that connection.<br><br>

</dd>
<dt><big><a name="color"></a>string <u>color</u>(string <i>text</i>, string <i>foreground</i>, string <i>background</i> = null);
</big></dt>
<dd>Format <i>text</i> to appear colored according to <i>foreground</i>, and optional <i>background</i> coloring,
    to IRC clients that support it.
<br><br>
There are enumerations available for the color codes <a href="#WHITE">here</a>.<br><br>

</dd>
<dt><big><a name="bold"></a>string <u>bold</u>(string <i>text</i>);
</big></dt>
<dd>Format <i>text</i> to appear bold to IRC clients that support it.<br><br>

</dd>
<dt><big><a name="italic"></a>string <u>italic</u>(string <i>text</i>);
</big></dt>
<dd>Format <i>text</i> to appear italicized to IRC clients that support it.<br><br>

</dd>
<dt><big><a name="underline"></a>string <u>underline</u>(string <i>text</i>);
</big></dt>
<dd>Format <i>text</i> to appear underlined to IRC clients that support it.<br><br>

</dd>
</dl>

        </body>
        </html>
